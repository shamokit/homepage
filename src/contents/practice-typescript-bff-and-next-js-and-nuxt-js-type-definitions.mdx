---
title: '実践TypeScript BFFとNext.js&Nuxt.jsの型定義'
date: '2022-03-24'
dateModified: '2022-04-25'
tags: [1,4,7,11]
private: false
category: 'books'
isbn: '978-4-8399-6937-0'
---
## 読んだ記録

- 262ページまで読んだ痕跡がある。ピザのはがきが挟んであった。
- 2022-04-16 最初から再度読み始める。
- 2022-04-25 第四章を読み終わった。

## 第一章 開発環境と設定
### VSCode TypeScriptの設定
デフォルトで最新の安定バージョンが適応される。

別のバージョンのTypeScript Language Serverを使用する場合はtsserver.jsファイルを含むディレクトリをtypescript.tsdkに設定する。

```json
{
	"typescript.tsdk": "./node_modules/typescript/lib"
}
```

TypeScriptのインストール場所は

```bash
npm list -g typescript
```

で確認できる。

### TypeScriptのインストール

```bash
npm i -g typescript
```

安定版よりも新しいバージョンを使いたい場合は

```bash
npm i -g typescript@next
```

### トランスパイル

```bash
tsc
```

### strict: true

有効になるのは以下

- noImplictAny
- noImplictThis
- alwaisStrict
- strict始まりのオプション

### 出力先の変更

```json
{
	"compilerOptions" : {
		"outDir": "dist" //出力先のディレクトリ
	},
	"include": [
		"src/**/*" //どこのファイルをトランスパイルするか
	]
}
```

### 型定義ファイル

```json
{
	"compilerOptions" : {
		"declaration": true
	},
}
```

.tsファイルに型を書かなくてもこうしておけば型定義ファイルのxxx.d.tsファイルが生成される。

ライブラリ開発で使うらしい。
関数に型を書くのとどう違うのだろうか…

### JavaScriptファイルをビルドに含ませる場合

```json
{
	"compilerOptions" : {
		"allowJs": true,
		"checkJs": true
	},
}
```

これでビルドが通るようになる。
同時にjsファイルでも型推論がきくようになる。

### build mode

|オプション|概要|
|:---|:---|
|--verbose|ビルド時の詳細ログを表示する|
|--dry|ビルドは行うが何も出力しない|
|--clean|出力を削除する|
|--watch|監視と変更時のビルド|

### tsconfig.jsonの設定項目

それぞれのオプションはここに全部載ってそう。
[https://www.typescriptlang.org/ja/tsconfig](https://www.typescriptlang.org/ja/tsconfig)

#### compilerOptions

- Basic Options
- Strict Type-Checking Options
- Additional Checks
- Module Resolution Options
- Source Map Options
- Experimental Options

に大きく分かれている。
[https://typescript-jp.gitbook.io/deep-dive/project/compilation-context/tsconfig](https://typescript-jp.gitbook.io/deep-dive/project/compilation-context/tsconfig)

#### references

同リポジトリ内でTypeScriptプロジェクトを分割できる。(モノレポ)

```json
{
	"references": [
		{"path": "../src"}
	]
}
```

pathプロパティはtsconfig.jsonを含むディレクトリへのパスを指定する。

参照プロジェクトのtsconfig.jsonでは

```json
{
	"compilerOptions": {
		"composite": true
	}
}
```

が必要。

## 第二章 TypeScriptの基礎

関数の引数の型注釈（アノテーション）は必ずつける。
戻り型注釈もできるだけつけたほうがよい。

### boolean型

```ts
let flag: boolean = true //or false
```

### number型

```ts
let count: number = 10 //0xfff,0b0000,0o123
```

### string型

```ts
let name: string = 'test' //"test",`test ${hoge}`
```

### array型

```ts
let list: string[] = ['test']
let list: Array<number> = [10]
```

### tuple型

```ts
let list: [string, number]
list = ['test', 10]
list = [10, 'test'] //error
```

### any,unknown型

```ts
const certainlyNumbers: number[] = ["0"] //error
const maybeNumbers: any[] = ["0"] //ok　←危険
//Number.prototype.toFixed()
maybeNumbers[0].toFixed() //ok　←危険
const probablyNumbers: unknown[] = ["0"] //ok　←危険
probablyNumbers[0].toFixed() //error　←安全
```

### void型

値を返さない関数に使用する。

```ts
const hoge = (): void => {
	console.log('hoge')
}
```

void型にはundefinedかnullのみ代入できる

```ts
let unusable: void = undefined
```

### null,undefined型

全ての型に代入できるので、tsconfig.jsonのstrictNullCheckをtrueにしてundefined,null型にしか代入できないようにしておいたほうがいい。

```ts
let u: undefined = undefined
let n: null = null
```

### never型

発生しえない値の型。指定しておくと条件分岐の漏れのチェックなどに使えるかも。

### object型

boolean number string symbol null undefined以外の非プリミティブ型を表す型。

```ts
let objectBrace: {}
let objectType: object
objectBrace = true //ok
objectType = true //error
```

### Intersection Types(交差型)

複数の型を結合する。

```ts
type Post {
	title: string
	content: string
}
type Category {
	title: string
	slug: string
}
type PostWithCategory = Post & { category: Category }
```
---
```ts
type PostWithCategory = {
	title: string
	content: string
	category: {
		title: string
		slug: string
	}
}
```

### Union Types(共用体)

複数の型のうち一つの型が成立することを表す。

```ts
let value: string | number
value = "10" //ok
value = 0 //ok
value = false //error
```

#### array型
```ts
let value: (string | number)[]
value = ["0", 0] //ok
value = [false] //error

```

#### nullable型
```ts
let value: string | null
value = null //ok
value = "OK" //ok
value = 0 //error
```

### Literal Types(文字列リテラル)

```ts
let name: 'しゃもきっと' | 'shamokit'
name = 'hoge' //error
name = 'しゃもきっと' //ok
name = 'shamokit' //ok
```

特定の値しか入れたくないときに使える。

### typeof keyof

#### typeof

変数の型を参照できる。

```ts
let testObject = {
	foo: "foo",
	bar: "bar"
}
type TypeTestObject = typeof testObject
let exampleObject: TypeTestObject = {
	foo: "foo",
	bar: "bar"
}
```

#### keyof

オブジェクトのプロパティの名称をString Literal Union Typesで取得できる。

```ts
type TypeTestObject = {
	foo: string
	bar: string
}
type TypeTestObjectKeyName = keyof TypeTestObject // 'foo' | 'bar'
const test:TypeTestObjectKeyName = 'bar' // foo barがサジェストされる
```

#### typeofとの併用

オブジェクトからのキー名だけの型を生成したりできる。

```ts
let testObject = {
	foo: "hoge",
	bar: "test"
}
type TypeObject = keyof typeof testObject // 'foo' | 'bar'
```

### アサーション(宣言)
この型だよ　と教えることができる。

```ts
let hoge: any = "test"
let stringLength: number = (<string>hoge).length //非推奨
```
---
```ts
let hoge: any = "test"
let stringLength: number = (hoge as string).length
```

### クラス

クラス内でも型はつけられる。

```ts
class Cube {
	protected width: number// protectedによりCubeもしくはサブクラスでのみ参照できる
	protected height: number
	private size: number// 同一クラス内でのみ参照できる
	constructor(width: number, height: number) {
		this.width = width
		this.height = height
	}
	protected scaleSize(scale: number) {// サブクラスからのみ実行できる
		return this.size * scale
	}
}
const cube = new Cube(100, 200)
console.log(cube.size) //private修飾子をつけているのでアクセスできない
console.log(cube.width) //protected修飾子をつけているのでアクセスできない
console.log(cube.scaleSize(1.2)) //protected修飾子をつけているのでアクセスできない
```
---
```ts
class SpecialCube extends Cube {
	//SpecialCube：Cubeのサブクラス
	//Cube：SpecialCubeのスーパークラス
	public name: string
	constructor(name: string) {
		super(100, 100)
		this.name = name
		console.log(this.size)//privateなのでサブクラスでは呼び出せない
	}
	getScaleSize(scale: number) {
		return this.scaleSize(scale) + "px" //protectedをつけているのでCubeもしくはそのサブクラス内でしか呼び出せない
	}
}
const specialCube = new SpecialCube('hoge')
console.log(specialCube.name) //publicなのでどこでも呼び出せる
```

## 第三章 TypeScriptの型推論

### JSONの型推論

jsonファイルのimportで型推論するにはtsconfig.jsonに

```json
{
	"compilerOptions": {
		"resolveJsonModule": true,
		"esModuleInterop": true
	}
}
```

が必要。

## 第四章 TypeScriptの型安全

### 関数の引数をオプションにする

```ts
export const hoge = (test?: string): string => { //hogeの返り型をstringにしておけばtestがoptionalで何も値がない時の処理を書き忘れなくて済む
	if(!test) return 'no Value' //引数が渡されなかったとき用の処理
	return `${test.trim()} !` //前の行でtestがない時が省かれているのでエラーが出ない
}
```

```if(!test) return 'no Value'```のような早期returnをガード節や**Type Guard**と呼ぶ。

### オブジェクトの型安全

```ts
type User = {
	id?: number
	name?: string
}
```

このようにすべてのプロパティがオプショナルな型を**Weak Type**と呼ぶ。

### 読み込み専用プロパティ

```ts
type User = {
	readonly name: string
}
const me: User = {
	name: "しゃもキット"
}
me.name = "test" //error
```
プロパティごとに```readonly```にしたい場合はキー名の前に```readonly```をつける。

---
```ts
type State = {
	id: number
	name: string
}
const state: Readonly<State> = {
	id: 10,
	name: 'しゃもきっと'
}
state.id = 100 //error
```

全てのプロパティを読み込み専用にしたい場合は```Readonly```型で一括```readonly```にできる。

```readonly```はあくまでの型情報なので、実際JavaScriptで変更は可能。
書き換えられないようにするには

```ts
type State = {
	id: number
	name: string
}
const state: State = {
	id: 10,
	name: 'しゃもきっと'
}
const frozenState = Object.freeze(state)
frozenState.id = 1000
```

のように```Object.freeze()```を使う必要がある。
```Object.freeze()```した変数の型は```Readonly```型に型推論される。

### 抽象度による型安全

```ts
const theme = {
	bg: "black",
	text: "white"
}
type Theme = typeof theme
```

このとき型推論は

```ts
type Theme = {
	bg: string
	text: string
}
```

こうなってしまう。より詳細な型にしたい場合

```ts
const theme = {
	bg: "black" as "black",
	text: "white" as "white"
}
type Theme = typeof theme
```

のようにする。このように抽象的な型から詳細な型を付与することをダウンキャストと呼ぶ。

反対に以下の例(```:any```)のように抽象度を上げることをアップキャストと呼ぶ。

```ts
const test = (hoge: string):any => {
	return hoge
}
const foo: number = test('1000')
foo.toFixed() //errorにならない
```

```test()```の返り値は```:any```をつけなければ```string```になっているので```const foo: number = test('1000')```がエラーになるはずだが、```any```にアップキャストしてしまっているせいで```toFixed()```部分でエラーがでなくなってしまった。

### オブジェクトに動的に値を追加する

キーを追加できるようにするには以下のようにやる

```ts
type User = {
	name: string
	[k: string]: string | number
}
const user: User = {
	name: 'しゃもきっと'
}
user['id'] = 100
```

```[k: string]```これをインデックスシグネチャという。

#### プロパティ型を制限する

```ts
type Answer = 'A' | 'B' | 'C'
type User = {
	name: string
	enquete: {
		[k: string]: Answer
	}
}
const user: User = {
	name: 'しゃもきっと',
	enquete: {
		exercise_habits: 'A',
		time_of_sleeping: 'B'
	}
}
const x = user.enquete['test'] //存在しないプロパティがAnswerに型推論されてしまう
const y = user.enquete['exercise_habits'] //undefinedなのにAnswerに推論される
```
---
```ts
type Answer = 'A' | 'B' | 'C'
type User = {
	name: string
	enquete: {
		[k: string]: Answer | undefined //undefined追加
	}
}
const user: User = {
	name: 'しゃもきっと',
	enquete: {
		exercise_habits: 'A',
		time_of_sleeping: 'B'
	}
}
const x = user.enquete['test'] //Answer | undefinedに型推論
const y = user.enquete.exercise_habits //Answer | undefinedに型推論
```

これでより安全になる。

#### プロパティ名を制約する

```ts
type Question = 'a' | 'b' | 'c'
type Answer = 'A' | 'B' | 'C'
type User = {
	name: string
	enquete: {
		[K in Question]?: Answer //?でundefinedが付与される
	}
}
const user: User = {
	name: 'しゃもきっと',
	enquete: {
		a: "A",
		d: "A", //Questionにaは許されていないのでエラーになる
	}
}
```

#### 関数プロパティのみ受け入れる

```ts
type Functions = {
	[k: string]: Function
}
const functions:Functions = {
	hoge: () => console.log('test'),//error
	test: 'test'//error
}
```

#### const assertion

```ts
const tuple1 = [false, 10, 'test'] as [false, 10, 'test']
const tuple2 = [false, 10, 'test'] as const
```

tuple1はtuple2で省略してかける。

#### Non-null assertion

```ts
const greet = (name?: string) => {
	return `${name!.trim()} !`
}
greet()
```

これはnameがない時エラーになるはずだがエラーが出ない。
```name!```の部分でnameの型がstring | undefined からstringになってしまう。(!でundefinedが取り除かれてしまう。)

このシグネチャはnullおよびundefinedではないと信用できる場所以外では使用してはいけない。

#### double assertion

```ts
const test = 0 as any as string
test.trim()
```

number型の0をsrtingに偽れてしまっている。ごく稀に役立つらしい。
基本使わない。

### typeof type guards

```ts
const test = (value: number | string | boolean):string => {
	if(typeof value === 'number') {
		return value.toString() //numberに型推論される
	}
	else if(typeof value === 'string') {
		return value //stringに型推論される
	}
	else  {
		return `${value}` //booleanに型推論される
	}
}
```

### in type guards

```ts
type Dog = {
	name: string
	bark: Function
}
type Cat = {
	name: string
	nail_sharpening: Function
}
const judgeAnimalType = (animal: Dog | Cat) => {
	if('bark' in animal) {
		console.log(`${animal} is Dog`) //Dogに型推論される
	} else {
		console.log(`${animal} is Cat`) //Catに型推論される
	}
}
```

### ユーザー定義type guards

```ts
type User = {
	name: string
	[k: string]: any
}
type UserA = User & {
	hobby: string
}
type UserB = User & {
	job: string
}
const isUserA = (user: UserA | UserB): user is UserA => {
	return user.hobby !== undefined
}
const user:UserA = {
	name: 'しゃもきっと',
	hobby: 'test'
}
const getUserType = (user: any) => {
	if(isUserA(user)) {
		console.log(user) //UserAに型推論される
		return 'A'
	}
	else {
		console.log(user) //anyに型推論される
		return 'any'
	}
}
const x = getUserType(user)
```

### Array.filterで型を絞り込む

```ts
type User = {
	name: string
	[k: string]: any
}
type UserA = User & {
	hobby: string
}
type UserB = User & {
	job: string
}
const users: (UserA | UserB)[] = [
	{
		name: 'jon',
		hobby: 'baseball'
	},
	{
		name: 'bob',
		hobby: 'soccer'
	},
	{
		name: 'lisa',
		job: 'engineer'
	}
]
// ユーザー定義ガード節でworkerの型をfilterでもUserBに絞り込める
const worker = users.filter((user: UserA | UserB): user is UserB => {
	return 'job' in user
})
```
